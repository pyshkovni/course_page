# Функции. Свойства и параметры функций

## Работа с функциями

### Проблема в задаче №3

В [задаче №3](third_task.md) про сотрудников мы рассмотрели несколько вариантов решения словари, списковые включения. Первый вариант решения задачи приведен в блоке кода ниже.

```Python
# словарь с сотрудниками
employees = {
    'Alice' : 100000,
    'Bob' : 99817,
    'Carol' : 122908,
    'Frank' : 88123,
    'Eve' : 93121
    }

# Пустой список топ-менеджеров
top_mgrs = []

# перебираем ключи и сравниваем значения зп с порогом 100к$
for name in employees:
    if employees[name] >= 100000:
        top_mgrs.append(name)

# вывод в консоль
print(f"Топ-менеджеры: {top_mgrs}")
```

Это решение хорошо работает для одного словаря. А что если требуется обработать несколько словарей? Тогда каждый раз необходимо повторять один и тот же код.

```Python
# Несколько словарей сотрудников
employees = {'Alice': 100000, 'Bob': 99817}
devs = {"Mike": 60000, "John": 45000}

# решение для employees
top_mgrs = []
for name in employees:
    if employees[name] >= 100000:
        top_mgrs.append(name)

# копия решения для devs
top_devs = []
for name in devs:
    if devs[name] >= 100000:
        top_devs.append(name)
```

### Создание и вызов функции

Выходом из ситуации является создание функции. **`Функция` - это последовательность инструкций, возвращающая некое значение**. Функции позволяют **вызывать** часть кода, который описан в ней.

Работа с функциями подразумевает несколько этапов:

* этап создания функции
* этап вызова функции

Для того, чтобы объявить функцию, необходимо:

* указать оператор `def`,
* задать имя функции,
* передать аргументы в скобках (если они нужны).

```Python
def get_top_mgrs(staff):
    pass
```

В данном примере:

* оператор `def` задает начало функции,
* `get_top_mgrs` - имя функции,
* `staff` - аргумент функции.
* оператор `pass` - пропуск действий

Для примера пусть функция возвращает значение аргумента `staff`. Для возврата значения из функции необходимо использовать **оператор `return`, который указывает, когда функция должна завершить свою работу и вернуть результат**. Тогда функция выполняет свою задачу: принимает данные и возвращает обработанные значения. `print()` внутри функций, желательно **не использовать!**

```Python
def get_top_mgrs(staff):
    return staff
```

**Обратите внимание**, что созданные нами функции являются таким же, как и встроенные print(), round(), type() и др. с одном только отличием, что встроенные функции хранятся внутри Python.

Перейдем к следующему этапу - **вызов функции**. Чтобы применить код, который написан внутри, необходимо **написать имя функции и в скобочках записать значение параметра staff**. Например, напишем строку _"Сотрудники!"_. Ожидаемо, функция вернет строку. Для того чтобы увидеть результат на экране используем print().

```Python
# Создание функции
def get_top_mgrs(staff):
    return staff

# Вызов функции
print(get_top_mgrs("Сотрудники!"))
```

Теперь эту функцию можно вызвать несколько раз с разным значением параметра.

```Python
# Создание функции
def get_top_mgrs(staff):
    return staff

# Три вызова функции с разными параметрами
print(get_top_mgrs("Сотрудники!"))
print(get_top_mgrs("Разработчики!"))
print(get_top_mgrs("Менеджеры!"))
```

Функции очень важны в программировании. Они позволяют реализовать принцип разработки программного обеспечения _Don't repeat yourself (принцип DRY)_, нацеленный на снижение повторения одинаковых операций в коде. Также функция является минимальной единицей программы, которую можно протестировать и выполнить другие операции над ней.

### Имена функций

Имена переменных в Python обычно обозначают существительные. Тогда **функция должна содержать в указание на действие** _(get, add и др.)_ и то над чем, это действие совершается _(get_value, divide_number)_.

**Остальные правила повторяют правила записи имен переменных**:

* имя функции должно начинаться с буквы;
* имя функции должно быть записано маленькими латинскими буквами;
* имя функции должно быть разделено нижним подчеркиванием `_`, если в названии переменной несколько слов.

**Обратите внимание, что функция должна делать ровно одно действие**. Например, вам нужно проделать над числом два или более арифметических действия: сложить _add_ и умножить _multiply_. Тогда лучше создать две разные функции, чем создавать функцию add_and_multiply_numbers.

### Решение задачи №3 в виде функции

Вернемся к решению задачи №3. Подготовим шаблон функции `get_top_mgrs()`.

```Python
# словарь с сотрудниками
employees = {
    'Alice' : 100000,
    'Bob' : 99817,
    'Carol' : 122908,
    'Frank' : 88123,
    'Eve' : 93121
    }

# Создание функции
def get_top_mgrs(staff):
    pass

# Вызов функции для словаря employees
print(get_top_mgrs(employees))
```

Теперь запишем решение задачи внутри функции. **Обратите внимание, что внутри функции действует аргумент `staff`**, которые обозначает обрабатываемый словарь. **Поэтому внутри функции все операции будут проводится со `staff`**, а не c `employees`.

```Python
# словарь с сотрудниками
employees = {
    'Alice' : 100000,
    'Bob' : 99817,
    'Carol' : 122908,
    'Frank' : 88123,
    'Eve' : 93121
    }

# Создание функции
def get_top_mgrs(staff):
    top_mgrs = []
    for name in staff:
        if staff[name] >= 100000:
            top_mgrs.append(name)
    return top_mgrs

# Вызов функции для словаря employees
print(get_top_mgrs(employees))
```

Функция `get_top_mgrs()` вызвана для словаря `employees`. Интерпретатор передает содержимое `employees` в аргумент `staff` и дальше работает с ним. В результате функция возвращает результат - список топ-менеджеров. Также это будет работать и для нескольких словарей.

```Python
# словарь с сотрудниками
# Несколько словарей сотрудников
employees = {'Alice': 100000, 'Bob': 99817}
devs = {"Mike": 60000, "John": 45000}

# Вызов функции для словарей
print(get_top_mgrs(employees), get_top_mgrs(devs))
```

## Свойства параметров функции

_в разработке_

### Именованные и позиционные параметры

_в разработке_

```Python
print()
```

## Вопросы по теме

### Вопрос 1

Каким будет результат выполнения кода ниже?

```Python
print (9//2)
# 4.5
# 4.0  
# 4
# Error
```

## Ответы на вопросы и пояснения

### Ответ на вопрос 1

Каким будет результат выполнения кода ниже?

```Python
print (9//2)
# 4.5
# 4.0  
# 4    <- правильно
# Error
```

**Обратите внимание! Пробелы**

Операция целочисленного деления не вызывает вопросов, но после `print` стоить пробел. Представим, что операция записана следующим образом:

```Python
print((2**4124)/224+532*23/(214**2))
```